<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/12/04/go-net/test/"/>
      <url>/2024/12/04/go-net/test/</url>
      
        <content type="html"><![CDATA[<p>test</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go-net/http标准库简明教程</title>
      <link href="/2024/12/02/go-net&amp;http%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2024/12/02/go-net&amp;http%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天懒了（bushi），快赶赶进度…<br>学习来源<a href="https://chatgpt.com/">ChatGPT</a>&amp;&amp;<a href="https://gobyexample-cn.github.io/http-clients">Go by example</a><br>本文会包括go的net/http标准库等基础知识！零基础小白请放心使用!<br>会有涉及计网的一点知识 <del>(本人也正在cs144里挣扎)</del><br><del>好难过下周要考计组和数据结构</del><br>长文预警！！！</p><h1 id="Go的net-http标准库"><a href="#Go的net-http标准库" class="headerlink" title="Go的net/http标准库"></a>Go的net/http标准库</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>net/http 是什么<br>它是 Go 标准库中用来处理 HTTP 请求和响应的模块，提供了构建 Web 服务的基本功能。  </li><li>核心组件  <ul><li>http.Server：表示 HTTP 服务器。  </li><li>http.Request：表示 HTTP 请求。  </li><li>http.ResponseWriter：用于构造 HTTP 响应。  </li><li>路由与处理器：通过 Handler 接口和 ServeMux 路由器来实现。  </li></ul></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, %s!&quot;</span>, r.URL.Path[<span class="number">1</span>:]) <span class="comment">// 响应内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler) <span class="comment">// 注册处理函数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Server is running on http://localhost:8080&quot;</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 启动服务器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，访问 <a href="http://localhost:8080/Go，浏览器将显示：Hello">http://localhost:8080/Go，浏览器将显示：Hello</a>, Go!</p><h2 id="分块详细解释"><a href="#分块详细解释" class="headerlink" title="分块详细解释"></a>分块详细解释</h2><h3 id="启动HTTP服务器"><a href="#启动HTTP服务器" class="headerlink" title="启动HTTP服务器"></a>启动HTTP服务器</h3><p><code>http.ListenAndServe</code>  </p><p>用于启动HTTP服务器  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 参数：  </span></span><br><span class="line"><span class="string">  - :8080：监听的端口。  </span></span><br><span class="line"><span class="string">  - nil：表示使用默认的路由器（http.DefaultServeMux）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 自定义`</span><span class="string">`http.Server`</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在 Go 的 net/http 标准库中，http.Server 是一个结构体，它表示一个 HTTP 服务器。相比直接使用 http.ListenAndServe，通过自定义 http.Server，可以对服务器的行为进行更细粒度的控制，比如设置超时时间、TLS 配置、监听地址等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### `</span><span class="string">`http.Server`</span><span class="string">`的结构</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr              <span class="type">string</span>           <span class="comment">// 监听地址（如 &quot;:8080&quot;）</span></span><br><span class="line">Handler           http.Handler     <span class="comment">// 请求处理器，默认是 http.DefaultServeMux</span></span><br><span class="line">ReadTimeout       time.Duration    <span class="comment">// 读取请求头的最大时间</span></span><br><span class="line">WriteTimeout      time.Duration    <span class="comment">// 写入响应的最大时间</span></span><br><span class="line">IdleTimeout       time.Duration    <span class="comment">// 连接空闲时间（HTTP/1.1 的 Keep-Alive）</span></span><br><span class="line">MaxHeaderBytes    <span class="type">int</span>              <span class="comment">// 请求头的最大字节数</span></span><br><span class="line">TLSConfig         *tls.Config      <span class="comment">// TLS 配置（用于 HTTPS）</span></span><br><span class="line">ConnState         <span class="function"><span class="keyword">func</span><span class="params">(net.Conn, ConnState)</span></span> <span class="comment">// 连接状态回调</span></span><br><span class="line">ErrorLog          *log.Logger      <span class="comment">// 自定义错误日志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求处理器-Handler"><a href="#请求处理器-Handler" class="headerlink" title="请求处理器(Handler)"></a>请求处理器(Handler)</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>Handler 是 Go 中处理 HTTP 请求的一个接口，它定义了以下方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ResponseWriter：<br>用于构建和发送 HTTP 响应。<br>通过它可以设置状态码、响应头以及响应体。  </li><li>Request：<br>表示客户端的 HTTP 请求。<br>包含请求方法、URL、头信息、表单数据等。  </li></ul><p>总结：Handler 是处理 HTTP 请求并返回 HTTP 响应的逻辑核心。</p><h4 id="实现Handler的两种方式"><a href="#实现Handler的两种方式" class="headerlink" title="实现Handler的两种方式"></a>实现Handler的两种方式</h4><h5 id="1-实现http-Handler接口"><a href="#1-实现http-Handler接口" class="headerlink" title="(1)实现http.Handler接口"></a>(1)实现<code>http.Handler</code>接口</h5><p>任何实现了<code>ServeHTTP(w http.ResponseWriter, r *http.Request)</code>方法的类型都可以作为一个 Handler。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *myHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line"><span class="comment">//h *myHandler是一个指针接收者，表示ServeHTTP 方法与 myHandler 类型的指针绑定</span></span><br><span class="line"><span class="comment">//http.ResponseWriter 是一个接口，用于构造并发送 HTTP 响应给客户端</span></span><br><span class="line"><span class="comment">//*http.Request 是一个指向请求对象的指针,封装了客户端发来的 HTTP 请求的全部信息</span></span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, you&#x27;ve hit %s\n&quot;</span>, r.URL.Path)</span><br><span class="line"><span class="comment">//r.URL 是标准库 net/url 定义的 url.URL 结构体，用来解析和存储 URL 的详细信息。</span></span><br><span class="line"><span class="comment">//fmt.Fprintf 是 Go 语言中的一个非常常用的函数，它属于 fmt 包</span></span><br><span class="line"><span class="comment">//用于将格式化的字符串输出到指定的 io.Writer 接口对象中，而不是直接输出到控制台。</span></span><br><span class="line"><span class="comment">//与 fmt.Printf 和 fmt.Println 等标准输出函数不同，fmt.Fprintf 可以将输出定向到文件、网络连接、HTTP 响应等任何实现了 io.Writer 接口的对象。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := &amp;myHandler&#123;&#125;</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, handler)</span><br><span class="line"><span class="comment">//func ListenAndServe(addr string, handler http.Handler) error</span></span><br><span class="line"><span class="comment">//addr string指定服务器的监听地址，包括 IP 和端口号。</span></span><br><span class="line"><span class="comment">//handler http.Handler处理 HTTP 请求的对象，通常是一个实现了 http.Handler 接口的实例。</span></span><br><span class="line"><span class="comment">//启动一个HTTP服务端，持续监听8080端口，直到收到客户端请求</span></span><br><span class="line"><span class="comment">//如果没有指定 IP 地址或域名，那么访问的默认是本机</span></span><br><span class="line">    <span class="comment">//当浏览器发起请求（通过 TCP 协议连接到 localhost:8080）时，服务器接收这个连接</span></span><br><span class="line">    <span class="comment">//解析收到的 HTTP 请求，将请求分发给注册的处理器 handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在terminal中键入<code>go run main.go</code>，然后在浏览器中键入<code>http://localhost:8080/hello</code>,得到<code>Hello, you&#39;ve hit /hello</code></p><p>这个过程中，浏览器相当于客户端，浏览器通过url(<a href="http://localhost:8080/hello)构造出http请求，然后通过DNS解析把域名换算成ip地址，这样客户端知道目标服务器是谁，然后建立tcp/ip连接，再把构造出的http请求发送到目标服务器，在这里也就是把请求发送到本机的8080端口。Go程序相当于服务端，收到并解析http请求，把请求分发给注册的处理器handler。">http://localhost:8080/hello)构造出http请求，然后通过DNS解析把域名换算成ip地址，这样客户端知道目标服务器是谁，然后建立tcp/ip连接，再把构造出的http请求发送到目标服务器，在这里也就是把请求发送到本机的8080端口。Go程序相当于服务端，收到并解析http请求，把请求分发给注册的处理器handler。</a>  </p><p>在 Go 中，http 包提供了一个非常核心的功能：通过 HTTP 路由将不同的请求（通常是 HTTP 方法和路径的组合）指向特定的处理器（Handler）。这个过程叫做 注册。</p><h5 id="2-使用-http-HandlerFunc"><a href="#2-使用-http-HandlerFunc" class="headerlink" title="(2)使用 http.HandlerFunc"></a>(2)使用 <code>http.HandlerFunc</code></h5><p>Go 提供了一个便利的方法，可以将普通函数直接用作 Handler。这是通过类型 http.HandlerFunc 实现的</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, you&#x27;ve hit %s\n&quot;</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, myHandler) <span class="comment">// 直接注册处理函数</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8080/test</code>将返回<code>Hello, you&#39;ve hit /test</code></p><p>如何实现的？<br>http.HandleFunc 的底层实现会将你传递的函数（如 myHandler）转为一个匿名的结构体，并为这个结构体实现 ServeHTTP 方法。这个匿名结构体的 ServeHTTP 方法就是你提供的 myHandler 函数。可以理解为 http.HandleFunc 自动为你完成了接口的实现。</p><h3 id="HTTP-请求对象-http-Request"><a href="#HTTP-请求对象-http-Request" class="headerlink" title="HTTP 请求对象 (http.Request)"></a>HTTP 请求对象 (http.Request)</h3><p>http.Request 是 Go 中处理 HTTP 请求的核心结构体，包含了许多关于请求的详细信息，包括请求方法、URL、头部、请求体等。通过这个结构体，你可以访问并处理各种与 HTTP 请求相关的数据，进而实现 HTTP 服务的功能。  </p><p>在本地显示读取控制。</p><h4 id="http-Request的主要字段（仅举例两个）"><a href="#http-Request的主要字段（仅举例两个）" class="headerlink" title="http.Request的主要字段（仅举例两个）"></a><code>http.Request</code>的主要字段（仅举例两个）</h4><ol><li><p><code>Method</code>（请求方法）</p><ul><li>类型：string</li><li>描述：表示 HTTP 请求的类型，如 GET、POST、PUT、DELETE 等。</li><li>例如，如果是一个 GET 请求，Method 会是 “GET”，如果是一个 POST 请求，Method 会是 “POST”。</li><li>例子：r.Method 可以帮助你判断请求的类型。</li></ul></li><li><p><code>URL</code>（请求的URL）</p><ul><li>类型：*url.URL</li><li>描述：表示客户端请求的 URL 地址。这个字段是一个指向 url.URL 结构体的指针，包含了完整的 URL 信息。</li><li>通过 r.URL.Path，你可以获取请求的路径（例如 /hello）。而 r.URL.Query() 可以用于获取 URL 查询参数（如 ?name=John）。</li><li>例子：<ul><li>r.URL.Path：/hello 代表访问路径。</li><li>r.URL.RawQuery：查询字符串部分，例如 name=John&amp;age=30。</li></ul></li></ul></li></ol><h3 id="HTTP-响应对象-http-ResponseWriter"><a href="#HTTP-响应对象-http-ResponseWriter" class="headerlink" title="HTTP 响应对象 (http.ResponseWriter)"></a>HTTP 响应对象 (http.ResponseWriter)</h3><p>示例代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line"><span class="comment">// 设置响应状态码为 201 Created</span></span><br><span class="line">w.WriteHeader(http.StatusCreated)</span><br><span class="line"><span class="comment">// 写入响应体内容</span></span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello, client!&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器，监听端口 8080</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h4><p>代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br></pre></td></tr></table></figure></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li><strong>响应头（HTTP Headers）</strong>是服务器向客户端提供的关于响应的元信息。</li><li>Content-Type 是一个常用的响应头，它告诉客户端响应体的内容类型和格式，帮助客户端正确解析和处理数据。</li><li><p>告知客户端数据类型：<br>客户端需要知道返回的数据是什么类型，以便正确解析。例如：  </p><ul><li>text/plain：表示纯文本。</li><li>text/html：表示 HTML 文档。</li><li>application/json：表示 JSON 数据。  </li></ul><p>如果没有正确设置，客户端可能会错误地解析或显示数据。</p></li><li><p>支持不同的客户端  </p><ul><li>浏览器、移动设备、API 客户端等都依赖 Content-Type 来决定如何处理服务器返回的数据。</li><li>例如，Content-Type: text/html 会让浏览器将响应当作网页渲染，而 Content-Type: application/json 会让 API 客户端将其解析为 JSON 对象。</li></ul></li></ul><h4 id="设置响应状态码"><a href="#设置响应状态码" class="headerlink" title="设置响应状态码"></a>设置响应状态码</h4><p>代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.WriteHeader(http.StatusCreated)</span><br></pre></td></tr></table></figure><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><blockquote><p>状态码的作用是面向客户端的  </p></blockquote><ul><li><p>客户端通过状态码判断请求结果</p><ul><li>状态码如 200 OK 表示请求成功。</li><li>状态码如 404 Not Found 表示客户端请求的资源不存在。</li><li>状态码如 500 Internal Server Error 表示服务器内部出了问题。</li></ul></li><li><p>客户端行为会依赖状态码</p><ul><li>浏览器看到 301 Moved Permanently 会自动重定向到新的 URL。</li><li>API 客户端根据 401 Unauthorized 提示用户需要登录。</li><li>搜索引擎看到 503 Service Unavailable 会知道服务器暂时不可用，稍后再尝试抓取页面。</li></ul></li></ul><h3 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h3><p>HTTP 客户端主要用于发送 HTTP 请求到指定的服务器，并接收服务器的响应。net/http 提供了一些简单易用的函数和类型，例如 http.Get、http.Post、http.Client 等。</p><h4 id="核心类型-amp-函数"><a href="#核心类型-amp-函数" class="headerlink" title="核心类型&amp;函数"></a>核心类型&amp;函数</h4><p>(1) http.Client<br>http.Client 是一个可配置的 HTTP 客户端，用于发送请求和接收响应。<br>默认客户端是 http.DefaultClient。<br>(2) http.Request<br>表示一个 HTTP 请求，包含请求方法、URL、头部、请求体等。<br>(3) http.Response<br>表示一个 HTTP 响应，包含状态码、头部、响应体等。<br>(4) 快捷方法  </p><ul><li>http.Get：发送简单的 GET 请求。</li><li>http.Post：发送简单的 POST 请求。</li><li>http.Head、http.PostForm 等：发送其他类型的请求。</li></ul><p><del>懒得写例子直接解释gobyexample里的</del></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span><span class="comment">//提供缓冲I/O操作</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;http://gobyexample.com&quot;</span>)</span><br><span class="line"><span class="comment">//发送一个http.Get到http://gobyexample.com</span></span><br><span class="line"><span class="comment">//返回响应对象http.Response和error</span></span><br><span class="line"><span class="comment">//resp是一个响应对象，包含状态码，头部和响应体</span></span><br><span class="line"><span class="comment">//err表示是否出错，如果不为nil则代表出错</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line"><span class="comment">//若出错，则终止程序，输出错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"><span class="comment">//保证在resp.Body使用完后立即关闭</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Response status:&quot;</span>, resp.Status)<span class="comment">//打印状态码</span></span><br><span class="line"></span><br><span class="line">    scanner := bufio.NewScanner(resp.Body)</span><br><span class="line"><span class="comment">//创造扫描器，逐行读取响应体中的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; scanner.Scan() &amp;&amp; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">//按行读取响应体，若有下一行则返回true</span></span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描是否有错误，有错误用panic抛出</span></span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP服务端"><a href="#HTTP服务端" class="headerlink" title="HTTP服务端"></a>HTTP服务端</h3><p>HTTP 服务端用于处理客户端的 HTTP 请求并返回响应。Go 提供了一个高效的 HTTP 服务器实现，支持路由处理和并发。</p><h4 id="核心类型-amp-函数-1"><a href="#核心类型-amp-函数-1" class="headerlink" title="核心类型&amp;函数"></a>核心类型&amp;函数</h4><p>(1) http.Handler<br>接口，表示 HTTP 请求的处理器。<br>需要实现 ServeHTTP(w http.ResponseWriter, r *http.Request) 方法。<br>(2) http.Server<br>表示一个 HTTP 服务器，包含监听地址、处理器和其他配置。<br>默认服务器是通过 http.ListenAndServe 启动的。<br>(3) http.ServeMux<br>默认的路由器，负责将请求分发给对应的 Handler。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;hello\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headers</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, headers := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">        <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;%v: %v\n&quot;</span>, name, h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/headers&quot;</span>, headers)</span><br><span class="line"><span class="comment">//注册了两个处理器</span></span><br><span class="line"><span class="comment">//一个打印hello，一个打印所有请求头</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go-单元测试</title>
      <link href="/2024/11/26/go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/11/26/go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>零基础小白可放心食用！有很多概念解释比如匹配or通配符等等，一起加油！</p></blockquote><p>学习来源：  </p><ul><li><a href="https://geektutu.com/post/quick-go-test.html">极客兔兔-Go Test单元测试简明教程</a></li><li><a href="https://chatgpt.com/">ChatGPT</a></li></ul><p>Go 的单元测试是 Go 语言中内置的一个重要功能，支持开发者快速验证代码的正确性。通过标准库 testing 和相关工具（如 go test），你可以编写简洁、高效的单元测试用例。</p><h1 id="单元测试基本概念"><a href="#单元测试基本概念" class="headerlink" title="单元测试基本概念"></a>单元测试基本概念</h1><ul><li>单元测试是指对代码中最小的可测试部分（如函数或方法）进行验证，以确保其行为符合预期。  </li><li>在 Go 中，单元测试文件以 _test.go 为后缀，测试函数以 Test 开头。  </li><li>Go 的测试框架是内置的，运行 go test 命令即可执行测试。  </li></ul><h1 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h1><p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example/</span><br><span class="line">    |--calc.go</span><br><span class="line">    |--calc_test.go</span><br></pre></td></tr></table></figure><br>例如calc.go代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func Add(a int, b int) int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Mul(a int, b int) int &#123;</span><br><span class="line">    return a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则在同一个包中的calc_test.go可以这么写<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">if ans := Add(1, 2); ans != 3 &#123;</span><br><span class="line">t.Errorf(&quot;1 + 2 expected be 3, but %d got&quot;, ans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ans := Add(-10, -20); ans != -30 &#123;</span><br><span class="line">t.Errorf(&quot;-10 + -20 expected be -30, but %d got&quot;, ans)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>文件名必须以 _test.go 结尾。</li><li>测试函数：<ul><li>名称必须以 Test 开头，例如 TestAdd。</li><li>参数为 *testing.T 类型，用于报告测试失败和日志。</li></ul></li><li>测试文件和函数需要在同一个包中。</li></ul><blockquote><p><em>*testing.T 是用于单元测试的参数类型，表示测试上下文。它提供了一系列方法，用于报告测试状态、记录日志、跳过测试等。</em>  </p><p><strong>testing.B 是基准测试的参数类型，表示基准测试上下文。基准测试用于衡量代码的性能，通过* </strong>testing.B 提供的方法控制基准测试的运行。*</p><p><em>*testing.M 是 TestMain 函数的参数类型，用于控制测试的整个生命周期。TestMain 是所有测试的入口点，可以在运行测试前后进行全局的初始化和清理工作。</em>    </p></blockquote><p>运行go test，改package下所有测试都会被运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">ok      example 0.009s</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">或 go <span class="built_in">test</span> -v，-v 参数会显示每个用例的测试结果，另外 -cover 参数可以查看覆盖率。</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">$ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">=== RUN   TestMul</span><br><span class="line">--- PASS: TestMul (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example 0.007s</span><br></pre></td></tr></table></figure><p><strong>覆盖率</strong><br>衡量测试用例对代码检查程度的指标，表示被测试的代码中实际被执行的部分占整个代码的比例。Go 提供了内置工具来分析测试覆盖率，通过 -cover 参数可以快速查看。<br>覆盖率通常以百分比表示，用来评估测试的有效性。测试覆盖率有以下几种类型：  </p><ul><li>语句覆盖率（Statement Coverage）：被执行的代码语句占总语句数的比例。</li><li>分支覆盖率（Branch Coverage）：被测试的代码中，分支条件（如 if 和 else）被覆盖的比例。</li><li>函数覆盖率（Function Coverage）：被调用的函数占总函数数的比例。  </li></ul><p>在 Go 中，-cover 参数默认显示语句覆盖率。  </p><p>如果只想运行其中的一个用例，例如 TestAdd，可以用 -run 参数指定，该参数支持通配符 *，和部分正则表达式，例如 ^、$。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -run TestAdd -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example 0.007s</span><br></pre></td></tr></table></figure><p><strong>匹配，通配符与正则表达式</strong></p><ul><li>匹配：在 Go 的单元测试中，-run 参数用于指定运行哪些测试用例，通过匹配测试函数的名称来决定哪些测试会被执行。具体来说，根据你提供的通配符或正则表达式，与测试函数的名字进行对比。如果函数的名字符合你给定的模式，那么该测试用例会被运行。  </li><li><p>匹配的种类：</p><ul><li><p>运行指定测试<br>运行TestAdd<code>go test -run=TestAdd</code>  </p></li><li><p>使用通配符  </p><ul><li>运行所有以Test开头的测试<code>go test -run=Test*</code></li></ul></li><li><p>使用正则表达式<br>运行以 Test 开头且包含 Add 或 Subtract 的测试函数<code>go test -run=^Test(Add|Subtract)$</code></p></li></ul></li></ul><h1 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a>子测试</h1><p>在 Go 中，子测试是一种强大的功能，可以在一个测试函数中组织和运行多个相关的子测试。通过使用子测试，你可以对一组逻辑相关的测试进行分组，并更清晰地描述每个测试的意图。这种功能通常用在参数化测试或者复杂场景的分层测试中。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>子测试是通过 t.Run(name, func(t *testing.T)) 创建的：  </p><ul><li>name：为子测试指定一个描述性名称，用于标识这个测试。</li><li>匿名函数 func(t *testing.T)：定义子测试的逻辑。</li><li>子测试会在父测试中运行，可以嵌套多层，形成类似层级结构的测试组织方式。</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被测试函数,应该在同源的另一个文件里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">//结构体切片tests，定义了一组测试输入和期望输出</span></span><br><span class="line">        </span><br><span class="line">name     <span class="type">string</span></span><br><span class="line">a, b     <span class="type">int</span></span><br><span class="line">expected <span class="type">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">        <span class="comment">//子测试的名字会出现，更容易定位错误</span></span><br><span class="line">&#123;<span class="string">&quot;Add positives&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Add negatives&quot;</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Add mixed&quot;</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历测试用例并运行子测试</span></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="comment">//匿名函数，内联在t.Run中</span></span><br><span class="line">            <span class="comment">//每个子测试调用时，匿名函数被立即执行</span></span><br><span class="line"><span class="comment">//匿名函数内部代码定义了子测试的具体行为</span></span><br><span class="line">            result := Add(tt.a, tt.b)</span><br><span class="line"><span class="keyword">if</span> result != tt.expected &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Add(%d, %d) = %d; want %d&quot;</span>, tt.a, tt.b, result, tt.expected)</span><br><span class="line">                <span class="comment">//t.Errorf 用于记录一条格式化的错误信息，同时标记当前测试失败。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行<code>go test -v</code></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestAdd</span><br><span class="line">=== RUN   TestAdd/Addnec</span><br><span class="line">=== RUN   TestAdd/Addpos</span><br><span class="line">=== RUN   TestAdd/Addmix</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addnec (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addpos (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addmix (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      go-practice     0.360s</span><br></pre></td></tr></table></figure><h3 id="嵌套子测试"><a href="#嵌套子测试" class="headerlink" title="嵌套子测试"></a>嵌套子测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func TestMath(t *testing.T) &#123;</span><br><span class="line">// 一级子测试</span><br><span class="line">t.Run(&quot;Addition&quot;, func(t *testing.T) &#123;</span><br><span class="line">if Add(1, 2) != 3 &#123;</span><br><span class="line">t.Error(&quot;Addition failed&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 二级子测试</span><br><span class="line">t.Run(&quot;Multiplication&quot;, func(t *testing.T) &#123;</span><br><span class="line">t.Run(&quot;Positive numbers&quot;, func(t *testing.T) &#123;</span><br><span class="line">if 2*3 != 6 &#123;</span><br><span class="line">t.Error(&quot;Multiplication failed for positive numbers&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">t.Run(&quot;Negative numbers&quot;, func(t *testing.T) &#123;</span><br><span class="line">if -2*-3 != 6 &#123;</span><br><span class="line">t.Error(&quot;Multiplication failed for negative numbers&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="帮助函数"><a href="#帮助函数" class="headerlink" title="帮助函数"></a>帮助函数</h1><p>Go 的 testing 包提供了一个特殊的函数 t.Helper()，可以用来标记一个函数是测试的帮助函数，从而在测试失败时，错误信息中忽略这个帮助函数的调用栈，直接指向调用帮助函数的实际测试函数。</p><p><strong>无帮助函数示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func Add(a, b int) int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    if result := Add(2, 3); result != 5 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(2, 3) = %d; want 5&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">    if result := Add(0, 0); result != 0 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(0, 0) = %d; want 0&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">    if result := Add(-1, -1); result != -2 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(-1, -1) = %d; want -2&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>含有帮助函数示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func checkAdd(t *testing.T, a, b, expected int) &#123;</span><br><span class="line">    t.Helper() // 标记为帮助函数</span><br><span class="line">    if result := Add(a, b); result != expected &#123;</span><br><span class="line">        t.Errorf(&quot;Add(%d, %d) = %d; want %d&quot;, a, b, result, expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    //复用，更简洁高效</span><br><span class="line">    checkAdd(t, 2, 3, 5)</span><br><span class="line">    checkAdd(t, 0, 0, 0)</span><br><span class="line">    checkAdd(t, -1, -1, -2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="setup和teardown"><a href="#setup和teardown" class="headerlink" title="setup和teardown"></a>setup和teardown</h1><p>在 Go 的测试中，Setup 和 Teardown 是两个常见的概念，用于在测试开始之前执行初始化工作（Setup），以及在测试结束之后进行清理工作（Teardown）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func setup() &#123;</span><br><span class="line">fmt.Println(&quot;Before all tests&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func teardown() &#123;</span><br><span class="line">fmt.Println(&quot;After all tests&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Test1(t *testing.T) &#123;</span><br><span class="line">fmt.Println(&quot;I&#x27;m test1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Test2(t *testing.T) &#123;</span><br><span class="line">fmt.Println(&quot;I&#x27;m test2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestMain(m *testing.M) &#123;</span><br><span class="line">setup()</span><br><span class="line">code := m.Run()</span><br><span class="line">teardown()</span><br><span class="line">os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>集中控制测试环境：<br>TestMain 允许在单个位置控制测试的初始化和清理逻辑，而无需在每个测试中手动处理。</li><li>确保环境一致性：<br>使用 setup 和 teardown 可以确保所有测试运行在一个受控的环境中，避免因测试环境问题导致的不一致结果。</li><li>可扩展性：<br>如果需要增加更多的全局操作（如日志记录或配置加载），可以很方便地在 setup 和 teardown 中添加。</li></ul><h1 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h1><p>Go 中的基准测试（Benchmarking）用于评估代码的性能，帮助开发者了解程序在执行时的效率和优化空间。与常规的单元测试不同，基准测试主要关注执行时间和性能瓶颈的定位，通过 testing 包中的 testing.B 类型来实现。testing.B 提供了一些方法和属性，可以用于测量函数的执行时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 被测试的函数</span><br><span class="line">func Add(a, b int) int &#123;</span><br><span class="line">return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基准测试函数</span><br><span class="line">func BenchmarkAdd(b *testing.B) &#123;</span><br><span class="line">// 基准测试循环</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">Add(1, 2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BenchmarkAdd 是基准测试函数。基准测试函数必须以 Benchmark 开头，并接收一个 *testing.B 类型的参数。</li><li>b.N 是基准测试的循环次数。testing.B 会根据需要调整这个值，以确保测试的执行时间足够长，能准确地测量性能。</li><li>b.N 会自动增长，确保函数执行足够多次，以消除偶然的波动。</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\code2024\go<span class="literal">-practice</span>&gt; go test <span class="literal">-bench</span> .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go<span class="literal">-practice</span></span><br><span class="line">cpu: Intel(<span class="built_in">R</span>) Core(TM) i7<span class="literal">-1065G7</span> CPU <span class="selector-tag">@</span> <span class="number">1.30</span>GHz</span><br><span class="line">Benchmark<span class="built_in">Add-8</span>          <span class="number">1000000000</span>               <span class="number">0.3078</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      go<span class="literal">-practice</span>     <span class="number">0.829</span>s</span><br></pre></td></tr></table></figure><p>如果在运行前基准测试需要一些耗时的配置，则可以使用 b.ResetTimer() 先重置定时器，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkHello(b *testing.B) &#123;</span><br><span class="line">    ... // 耗时操作</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        fmt.Sprintf(&quot;hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go-并发编程</title>
      <link href="/2024/11/25/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/11/25/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前从未接触过并发编程的童鞋可放心食用！  </p><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><ul><li>并发 (Concurrency)：<br>并发是指同时处理多个任务的能力，但这些任务不一定是同时执行的。任务可能通过切换来共享时间片。  </li><li>并行 (Parallelism)：<br>并行是指多个任务同时执行，需要多个处理器核心支持。在 Go 中，Goroutine 是通过调度器来实现并发，最终通过 CPU 核心实现并行。</li></ul><p>并发和并行的关系：<br>并发是逻辑上的任务切换，而并行是物理上的任务同时运行。</p><h1 id="Go的并发核心：Goroutine"><a href="#Go的并发核心：Goroutine" class="headerlink" title="Go的并发核心：Goroutine"></a>Go的并发核心：Goroutine</h1><h2 id="Goroutine是什么"><a href="#Goroutine是什么" class="headerlink" title="Goroutine是什么"></a>Goroutine是什么</h2><p>Goroutine 是 Go 的协程实现，是一种比传统线程更轻量级的并发任务单元。</p><ul><li>轻量：一个 Goroutine 启动时仅占用大约 2 KB 的内存（相比线程，通常占用 1 MB 堆栈）。  </li><li>调度灵活：由 Go 的运行时（runtime）管理调度，而不是直接依赖操作系统内核线程。  </li><li>高效：Go 的运行时会动态调整 Goroutine 的栈大小（最小 2 KB，最大可达 1 GB），并通过用户态线程池实现调度。  </li></ul><p>协程 vs 线程：  </p><ul><li>线程：由操作系统调度，重量级，开销较大（如栈内存固定且较大、上下文切换代价高）。  </li><li>协程：由语言运行时调度，轻量级，开销小（动态栈、用户态上下文切换）。</li></ul><h2 id="创建和使用-Goroutine"><a href="#创建和使用-Goroutine" class="headerlink" title="创建和使用 Goroutine"></a>创建和使用 Goroutine</h2><p>创建一个 Goroutine 的方法非常简单，使用 go 关键字即可。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Task is running&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> task() <span class="comment">// 启动一个 Goroutine</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Main function&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 确保主 Goroutine 不退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>运行结果（顺序不可预测，Task is running可能都不会输出）：</em></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main function</span><br><span class="line">Task is running</span><br></pre></td></tr></table></figure><ul><li>go task()：启动一个新的 Goroutine，运行 task 函数。</li><li>主 Goroutine 继续执行 fmt.Println(“Main function”)。</li><li>如果没有 time.Sleep，主 Goroutine 会立即退出，程序结束，task 可能尚未完成。 </li></ul><h2 id="Goroutine的生命周期"><a href="#Goroutine的生命周期" class="headerlink" title="Goroutine的生命周期"></a>Goroutine的生命周期</h2><p>(1) 启动 Goroutine  </p><ul><li>Goroutine 是通过 go 关键字启动的。</li><li>每个 Goroutine 都会独立执行其任务，但与其他 Goroutine 和主 Goroutine 共享相同的地址空间。  </li></ul><p>(2) 运行中</p><ul><li>Goroutine 的调度由 Go 运行时管理，运行时会将多个 Goroutine 映射到少量的系统线程（M:N 模型）。</li><li>Goroutine 的执行顺序不确定，由运行时的调度算法决定。  </li></ul><p>(3) 结束</p><ul><li>Goroutine 执行完成或返回时会自动退出，无需显式销毁。</li></ul><h1 id="Goroutine-之间的同步与通信工具"><a href="#Goroutine-之间的同步与通信工具" class="headerlink" title="Goroutine 之间的同步与通信工具"></a>Goroutine 之间的同步与通信工具</h1><h2 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h2><p>sync 提供了一组基础的同步原语，用于解决 Goroutine 之间的同步问题，确保共享数据在多 Goroutine 环境下安全访问。</p><h3 id="常见的-sync-工具"><a href="#常见的-sync-工具" class="headerlink" title="常见的 sync 工具"></a>常见的 sync 工具</h3><p> <em>(1) sync.WaitGroup</em><br> 作用：等待一组 Goroutine 完成。<br> WaitGroup 提供了三个方法：</p><ul><li>Add(delta int)：设置需要等待的 Goroutine 数量（+delta）。</li><li>Done()：每当一个 Goroutine 完成任务，调用一次，表示减少一个需要等待的任务（-1）。</li><li>Wait()：阻塞主 Goroutine，直到所有计数归零。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// 减少计数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d is starting\n&quot;</span>, id)</span><br><span class="line"><span class="comment">// 模拟工作任务</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d is done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 增加计数</span></span><br><span class="line"><span class="keyword">go</span> worker(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">// 阻塞，直到所有任务完成</span></span><br><span class="line">fmt.Println(<span class="string">&quot;All workers are done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>注：Goroutines 是按照 for 循环的顺序启动的（1, 2, 3）。这意味着 Goroutines 被创建时的顺序是确定的。实际执行顺序取决于 Go 运行时调度器，调度器会决定哪个 Goroutine 先运行。</em></li></ul><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>Channel 是 Go 语言中用于 在 Goroutines 之间传递数据的核心机制之一。它是 Go 中并发编程的一个重要特性，可以让不同的 Goroutines 安全地通信和同步。Channel 是一种类型化的管道，可以用于在多个 Goroutines 之间传递消息，且无需使用锁（mutex）来保证同步。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><em>声明与初始化</em>：<br>使用 make 函数创建一个 channel，并可以指定容量（缓冲区大小）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> Type  <span class="comment">// 声明一个空的 channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> Type)  <span class="comment">// 创建一个 channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Type)  <span class="comment">// 声明并初始化一个 channel</span></span><br><span class="line"><span class="comment">//Type 是通过 channel 传递的数据类型，表示你希望在 channel 中传递的数据类型。</span></span><br></pre></td></tr></table></figure><br><em>发送数据&amp;接收数据</em><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- data  <span class="comment">// 将数据发送到 channel</span></span><br><span class="line">data := &lt;-ch  <span class="comment">// 从 channel 接收数据并赋值给变量</span></span><br></pre></td></tr></table></figure><br><em>关闭 Channel</em><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)  <span class="comment">// 关闭 channel</span></span><br><span class="line"><span class="comment">//使用 close(ch) 来关闭一个 channel，表示没有更多的数据会发送到该 channel。</span></span><br><span class="line"><span class="comment">//close 主要用于通知接收方，数据传输已经结束，接收方可以在接收数据时检查 channel 是否已关闭。</span></span><br></pre></td></tr></table></figure></p><h3 id="缓冲区与非缓冲区"><a href="#缓冲区与非缓冲区" class="headerlink" title="缓冲区与非缓冲区"></a>缓冲区与非缓冲区</h3><ul><li>非缓冲 channel：<br>发送方和接收方必须同时准备好，才能完成数据传递。发送方在发送数据时会阻塞，直到有接收方准备好接收数据。  </li><li>缓冲 channel：<br>可以预设一个缓冲区大小，在发送数据时，若缓冲区未满，发送方不会阻塞。只有当缓冲区满时，发送方才会被阻塞。接收方也不会立即阻塞，直到缓冲区为空时</li></ul><p><strong>非缓冲channel示例</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)  <span class="comment">// 创建一个非缓冲 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个 Goroutine 发送数据</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="string">&quot;Hello, Go!&quot;</span>  <span class="comment">// 发送数据到 channel</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据并输出</span></span><br><span class="line">    message := &lt;-ch  <span class="comment">// 从 channel 接收数据</span></span><br><span class="line">    fmt.Println(message)  <span class="comment">// 输出接收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>主 Goroutine 会阻塞在 message := &lt;-ch 直到接收到来自其他 Goroutine 的数据。</li><li>ch &lt;- “Hello, Go!” 会将数据发送到 channel，并且发送操作会阻塞，直到主 Goroutine 执行完 &lt;-ch 来接收数据。</li></ul><p><strong>缓冲channel示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan string, 2)  // 创建一个缓冲区大小为 2 的 channel</span><br><span class="line"></span><br><span class="line">    // 启动一个 Goroutine 发送数据</span><br><span class="line">    go func() &#123;</span><br><span class="line">        ch &lt;- &quot;Message 1&quot;</span><br><span class="line">        ch &lt;- &quot;Message 2&quot;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    // 接收并输出数据</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>创建了一个缓冲区大小为 2 的 channel，因此可以在没有阻塞的情况下向 channel 发送 2 条消息。</li><li>当我们从 channel 中接收数据时，如果缓冲区不为空，就能顺利获取到数据。</li><li>若发送3条消息，则会阻塞，直到缓冲区被释放</li></ul><h3 id="Channel-的同步与-Goroutines-协作"><a href="#Channel-的同步与-Goroutines-协作" class="headerlink" title="Channel 的同步与 Goroutines 协作"></a>Channel 的同步与 Goroutines 协作</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)  <span class="comment">// 模拟任务执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is done\n&quot;</span>, id)</span><br><span class="line">    ch &lt;- <span class="literal">true</span>  <span class="comment">// 通知任务完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">3</span>)  <span class="comment">// 创建一个缓冲区大小为 3 的 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(i, ch)  <span class="comment">// 启动多个 Goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有 Goroutine 完成</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        &lt;-ch  <span class="comment">// 从 channel 接收任务完成的信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;All workers are done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里使用了一个 缓冲 channel 来通知主 Goroutine 每个子 Goroutine 的任务完成。每个工作 Goroutine 在完成任务后通过 ch &lt;- true 向 channel 发送信号。</li><li>主 Goroutine 在 for 循环中通过 &lt;-ch 等待所有任务的完成，直到接收到所有的完成信号。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go-语言</title>
      <link href="/2024/11/25/go-%E8%AF%AD%E8%A8%80/"/>
      <url>/2024/11/25/go-%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>语言学习来源：</p><ul><li><a href="https://gobyexample-cn.github.io/">go-by-example</a></li><li><a href="https://geektutu.com/post/quick-golang.html">极客兔兔go简明教程</a>  </li></ul><p>原来过语言是看个输入输出直接去做题（但是后面看其实没怎么学跟项目有关的），而且这赶上期末&amp;手上有抓紧的项目，换一种方法。速通一下语言，之前学过一点点go语言皮毛，本文主要记录go在语言方面我觉得有趣不同的地方。ps：下一篇涉及并发编程&amp;单元测试</p><h1 id="string-amp-rune"><a href="#string-amp-rune" class="headerlink" title="string&amp;rune"></a>string&amp;rune</h1><p>字符串是以 byte 数组形式保存的，类型是 uint8，占1个 byte（中文一般占3byte），打印时需要用 string 进行类型转换&amp;用printf格式化，否则打印的是编码值。<br>为了更方便地处理字符（尤其是 Unicode 字符），Go 提供了 rune 类型作为字符的抽象，尤其是在处理多字节字符时，例如，字符 汉 是一个 Unicode 字符，在 UTF-8 编码下占用了 3 个字节，但作为 rune 类型，它是一个单独的值，可以直接进行操作。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, 世界!&quot;</span></span><br><span class="line">rs := []<span class="type">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> runes &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>, r) </span><br><span class="line">     <span class="comment">// 输出每个字符，分别是 H e l l o ,   世 界 !</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片实际上是一个描述符，包含以下三个部分：  </p><ul><li>指向底层数组的指针：切片的数据存储在底层数组中。  </li><li>长度（length）：切片当前的元素数。  </li><li>容量（capacity）：从切片起始位置到底层数组末尾的最大元素数。  </li></ul><p>多个切片可能共享同一个底层数组，如果需要独立操作，应使用 copy 创建新的切片。如果切片扩容导致底层数组更换，原切片和新切片将不再共享同一数组。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从数组创建</span></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  <span class="comment">// 数组</span></span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">4</span>]                 <span class="comment">// 从数组创建切片，包含索引 1 到 3 的元素</span></span><br><span class="line">fmt.Println(s)                <span class="comment">// [2 3 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)          <span class="comment">// 创建长度为 5 的切片，初始值为零值</span></span><br><span class="line">fmt.Println(s)               <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)      <span class="comment">// 创建长度为 3，容量为 5 的切片</span></span><br><span class="line">fmt.Println(s2)              <span class="comment">// [0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//make函数</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//type: 数据结构的类型，必须是 slice、map 或 channel。</span></span><br><span class="line"><span class="comment">//len: 数据结构的长度（对于切片和通道来说是可选参数）。</span></span><br><span class="line"><span class="comment">//cap: 数据结构的容量（仅对切片和带缓冲的通道有效，是可选参数）。</span></span><br><span class="line"><span class="comment">//如果没有显式指定容量，默认容量等于长度：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取长度，容量</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 长度: 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">// 容量: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片  </span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sub := s[<span class="number">1</span>:<span class="number">4</span>]         <span class="comment">// 从索引 1 到索引 3（不包含 4）</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [2 3 4]</span></span><br><span class="line"></span><br><span class="line">sub = s[:<span class="number">3</span>]           <span class="comment">// 从索引 0 到 2</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [1 2 3]</span></span><br><span class="line"></span><br><span class="line">sub = s[<span class="number">2</span>:]           <span class="comment">// 从索引 2 到末尾</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [3 4 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增长</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>)   <span class="comment">// 增加多个元素</span></span><br><span class="line">fmt.Println(s)        <span class="comment">// [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅声明</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 声明时初始化</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Sam&quot;</span>: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line"><span class="string">&quot;Alice&quot;</span>: <span class="string">&quot;Female&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="defer-amp-recover"><a href="#defer-amp-recover" class="headerlink" title="defer&amp;recover"></a>defer&amp;recover</h1><p>被 defer 的函数调用会在所在函数返回前（无论是正常返回还是因 panic 提前退出）被执行。<br>函数运行时，先跑别的，然后去找并运行defer函数（<em>被 defer 的函数调用会在所在函数返回前——无论是正常返回还是因 panic 提前退出——被执行。</em>）。在defer函数内部调用recover函数，捕获恢复程序<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(index <span class="type">int</span>)</span></span> (ret <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Some error happened!&quot;</span>, r)</span><br><span class="line">ret = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">return</span> arr[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(get(<span class="number">5</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h2><p><mark>隐式接口实现    </p><p>Go 使用隐式接口实现机制，意思是你不需要显式地声明一个类型实现了某个接口。</p><p>只要一个类型提供了接口所要求的<mark>全部方法（包括方法的名字、参数、返回值类型都一致）</mark>，那么 Go 就会认为这个类型实现了该接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">getName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stu.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p Person = &amp;Student&#123;</span><br><span class="line">name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(p.getName()) <span class="comment">// Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：  </p><ul><li>定义接口 Person 和两个结构体 Student 和 Worker。  </li><li>实现 getName 方法，使得 <em>Student 和 </em>Worker 都满足 Person 接口。  </li><li>在 main 函数中：<ul><li>创建一个 *Student 的实例。</li><li>将其赋值给 Person 类型变量 p。</li><li>调用 p.getName() 方法，实际执行的是 *Student.getName，返回 Tom。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
