<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flypiggy&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-26T16:03:24.298Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>qustfp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/11/26/hello-world/"/>
    <id>http://example.com/2024/11/26/hello-world/</id>
    <published>2024-11-26T16:03:24.298Z</published>
    <updated>2024-11-26T16:03:24.298Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog!<br>好运气好心情!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to my blog!&lt;br&gt;好运气好心情!&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>go-单元测试</title>
    <link href="http://example.com/2024/11/26/go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2024/11/26/go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2024-11-26T09:21:04.000Z</published>
    <updated>2024-11-26T16:03:24.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>零基础小白可放心食用！有很多概念解释比如匹配or通配符等等，一起加油！</p></blockquote><p>学习来源：  </p><ul><li><a href="https://geektutu.com/post/quick-go-test.html">极客兔兔-Go Test单元测试简明教程</a></li><li><a href="https://chatgpt.com/">ChatGPT</a></li></ul><p>Go 的单元测试是 Go 语言中内置的一个重要功能，支持开发者快速验证代码的正确性。通过标准库 testing 和相关工具（如 go test），你可以编写简洁、高效的单元测试用例。</p><h1 id="单元测试基本概念"><a href="#单元测试基本概念" class="headerlink" title="单元测试基本概念"></a>单元测试基本概念</h1><ul><li>单元测试是指对代码中最小的可测试部分（如函数或方法）进行验证，以确保其行为符合预期。  </li><li>在 Go 中，单元测试文件以 _test.go 为后缀，测试函数以 Test 开头。  </li><li>Go 的测试框架是内置的，运行 go test 命令即可执行测试。  </li></ul><h1 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h1><p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example/</span><br><span class="line">    |--calc.go</span><br><span class="line">    |--calc_test.go</span><br></pre></td></tr></table></figure><br>例如calc.go代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func Add(a int, b int) int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Mul(a int, b int) int &#123;</span><br><span class="line">    return a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则在同一个包中的calc_test.go可以这么写<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">if ans := Add(1, 2); ans != 3 &#123;</span><br><span class="line">t.Errorf(&quot;1 + 2 expected be 3, but %d got&quot;, ans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ans := Add(-10, -20); ans != -30 &#123;</span><br><span class="line">t.Errorf(&quot;-10 + -20 expected be -30, but %d got&quot;, ans)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>文件名必须以 _test.go 结尾。</li><li>测试函数：<ul><li>名称必须以 Test 开头，例如 TestAdd。</li><li>参数为 *testing.T 类型，用于报告测试失败和日志。</li></ul></li><li>测试文件和函数需要在同一个包中。</li></ul><blockquote><p><em>*testing.T 是用于单元测试的参数类型，表示测试上下文。它提供了一系列方法，用于报告测试状态、记录日志、跳过测试等。</em>  </p><p><strong>testing.B 是基准测试的参数类型，表示基准测试上下文。基准测试用于衡量代码的性能，通过* </strong>testing.B 提供的方法控制基准测试的运行。*</p><p><em>*testing.M 是 TestMain 函数的参数类型，用于控制测试的整个生命周期。TestMain 是所有测试的入口点，可以在运行测试前后进行全局的初始化和清理工作。</em>    </p></blockquote><p>运行go test，改package下所有测试都会被运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">ok      example 0.009s</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">或 go <span class="built_in">test</span> -v，-v 参数会显示每个用例的测试结果，另外 -cover 参数可以查看覆盖率。</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">$ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">=== RUN   TestMul</span><br><span class="line">--- PASS: TestMul (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example 0.007s</span><br></pre></td></tr></table></figure><p><strong>覆盖率</strong><br>衡量测试用例对代码检查程度的指标，表示被测试的代码中实际被执行的部分占整个代码的比例。Go 提供了内置工具来分析测试覆盖率，通过 -cover 参数可以快速查看。<br>覆盖率通常以百分比表示，用来评估测试的有效性。测试覆盖率有以下几种类型：  </p><ul><li>语句覆盖率（Statement Coverage）：被执行的代码语句占总语句数的比例。</li><li>分支覆盖率（Branch Coverage）：被测试的代码中，分支条件（如 if 和 else）被覆盖的比例。</li><li>函数覆盖率（Function Coverage）：被调用的函数占总函数数的比例。  </li></ul><p>在 Go 中，-cover 参数默认显示语句覆盖率。  </p><p>如果只想运行其中的一个用例，例如 TestAdd，可以用 -run 参数指定，该参数支持通配符 *，和部分正则表达式，例如 ^、$。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -run TestAdd -v</span><br><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      example 0.007s</span><br></pre></td></tr></table></figure><p><strong>匹配，通配符与正则表达式</strong></p><ul><li>匹配：在 Go 的单元测试中，-run 参数用于指定运行哪些测试用例，通过匹配测试函数的名称来决定哪些测试会被执行。具体来说，根据你提供的通配符或正则表达式，与测试函数的名字进行对比。如果函数的名字符合你给定的模式，那么该测试用例会被运行。  </li><li><p>匹配的种类：</p><ul><li><p>运行指定测试<br>运行TestAdd<code>go test -run=TestAdd</code>  </p></li><li><p>使用通配符  </p><ul><li>运行所有以Test开头的测试<code>go test -run=Test*</code></li></ul></li><li><p>使用正则表达式<br>运行以 Test 开头且包含 Add 或 Subtract 的测试函数<code>go test -run=^Test(Add|Subtract)$</code></p></li></ul></li></ul><h1 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a>子测试</h1><p>在 Go 中，子测试是一种强大的功能，可以在一个测试函数中组织和运行多个相关的子测试。通过使用子测试，你可以对一组逻辑相关的测试进行分组，并更清晰地描述每个测试的意图。这种功能通常用在参数化测试或者复杂场景的分层测试中。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>子测试是通过 t.Run(name, func(t *testing.T)) 创建的：  </p><ul><li>name：为子测试指定一个描述性名称，用于标识这个测试。</li><li>匿名函数 func(t *testing.T)：定义子测试的逻辑。</li><li>子测试会在父测试中运行，可以嵌套多层，形成类似层级结构的测试组织方式。</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被测试函数,应该在同源的另一个文件里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">//结构体切片tests，定义了一组测试输入和期望输出</span></span><br><span class="line">        </span><br><span class="line">name     <span class="type">string</span></span><br><span class="line">a, b     <span class="type">int</span></span><br><span class="line">expected <span class="type">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">        <span class="comment">//子测试的名字会出现，更容易定位错误</span></span><br><span class="line">&#123;<span class="string">&quot;Add positives&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Add negatives&quot;</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Add mixed&quot;</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历测试用例并运行子测试</span></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="comment">//匿名函数，内联在t.Run中</span></span><br><span class="line">            <span class="comment">//每个子测试调用时，匿名函数被立即执行</span></span><br><span class="line"><span class="comment">//匿名函数内部代码定义了子测试的具体行为</span></span><br><span class="line">            result := Add(tt.a, tt.b)</span><br><span class="line"><span class="keyword">if</span> result != tt.expected &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;Add(%d, %d) = %d; want %d&quot;</span>, tt.a, tt.b, result, tt.expected)</span><br><span class="line">                <span class="comment">//t.Errorf 用于记录一条格式化的错误信息，同时标记当前测试失败。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行<code>go test -v</code></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestAdd</span><br><span class="line">=== RUN   TestAdd/Addnec</span><br><span class="line">=== RUN   TestAdd/Addpos</span><br><span class="line">=== RUN   TestAdd/Addmix</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addnec (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addpos (0.00s)</span><br><span class="line">    --- PASS: TestAdd/Addmix (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      go-practice     0.360s</span><br></pre></td></tr></table></figure><h3 id="嵌套子测试"><a href="#嵌套子测试" class="headerlink" title="嵌套子测试"></a>嵌套子测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func TestMath(t *testing.T) &#123;</span><br><span class="line">// 一级子测试</span><br><span class="line">t.Run(&quot;Addition&quot;, func(t *testing.T) &#123;</span><br><span class="line">if Add(1, 2) != 3 &#123;</span><br><span class="line">t.Error(&quot;Addition failed&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 二级子测试</span><br><span class="line">t.Run(&quot;Multiplication&quot;, func(t *testing.T) &#123;</span><br><span class="line">t.Run(&quot;Positive numbers&quot;, func(t *testing.T) &#123;</span><br><span class="line">if 2*3 != 6 &#123;</span><br><span class="line">t.Error(&quot;Multiplication failed for positive numbers&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">t.Run(&quot;Negative numbers&quot;, func(t *testing.T) &#123;</span><br><span class="line">if -2*-3 != 6 &#123;</span><br><span class="line">t.Error(&quot;Multiplication failed for negative numbers&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="帮助函数"><a href="#帮助函数" class="headerlink" title="帮助函数"></a>帮助函数</h1><p>Go 的 testing 包提供了一个特殊的函数 t.Helper()，可以用来标记一个函数是测试的帮助函数，从而在测试失败时，错误信息中忽略这个帮助函数的调用栈，直接指向调用帮助函数的实际测试函数。</p><p><strong>无帮助函数示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func Add(a, b int) int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    if result := Add(2, 3); result != 5 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(2, 3) = %d; want 5&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">    if result := Add(0, 0); result != 0 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(0, 0) = %d; want 0&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">    if result := Add(-1, -1); result != -2 &#123;</span><br><span class="line">        t.Errorf(&quot;Add(-1, -1) = %d; want -2&quot;, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>含有帮助函数示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func checkAdd(t *testing.T, a, b, expected int) &#123;</span><br><span class="line">    t.Helper() // 标记为帮助函数</span><br><span class="line">    if result := Add(a, b); result != expected &#123;</span><br><span class="line">        t.Errorf(&quot;Add(%d, %d) = %d; want %d&quot;, a, b, result, expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestAdd(t *testing.T) &#123;</span><br><span class="line">    //复用，更简洁高效</span><br><span class="line">    checkAdd(t, 2, 3, 5)</span><br><span class="line">    checkAdd(t, 0, 0, 0)</span><br><span class="line">    checkAdd(t, -1, -1, -2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="setup和teardown"><a href="#setup和teardown" class="headerlink" title="setup和teardown"></a>setup和teardown</h1><p>在 Go 的测试中，Setup 和 Teardown 是两个常见的概念，用于在测试开始之前执行初始化工作（Setup），以及在测试结束之后进行清理工作（Teardown）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func setup() &#123;</span><br><span class="line">fmt.Println(&quot;Before all tests&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func teardown() &#123;</span><br><span class="line">fmt.Println(&quot;After all tests&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Test1(t *testing.T) &#123;</span><br><span class="line">fmt.Println(&quot;I&#x27;m test1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Test2(t *testing.T) &#123;</span><br><span class="line">fmt.Println(&quot;I&#x27;m test2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestMain(m *testing.M) &#123;</span><br><span class="line">setup()</span><br><span class="line">code := m.Run()</span><br><span class="line">teardown()</span><br><span class="line">os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>集中控制测试环境：<br>TestMain 允许在单个位置控制测试的初始化和清理逻辑，而无需在每个测试中手动处理。</li><li>确保环境一致性：<br>使用 setup 和 teardown 可以确保所有测试运行在一个受控的环境中，避免因测试环境问题导致的不一致结果。</li><li>可扩展性：<br>如果需要增加更多的全局操作（如日志记录或配置加载），可以很方便地在 setup 和 teardown 中添加。</li></ul><h1 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h1><p>Go 中的基准测试（Benchmarking）用于评估代码的性能，帮助开发者了解程序在执行时的效率和优化空间。与常规的单元测试不同，基准测试主要关注执行时间和性能瓶颈的定位，通过 testing 包中的 testing.B 类型来实现。testing.B 提供了一些方法和属性，可以用于测量函数的执行时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;testing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 被测试的函数</span><br><span class="line">func Add(a, b int) int &#123;</span><br><span class="line">return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基准测试函数</span><br><span class="line">func BenchmarkAdd(b *testing.B) &#123;</span><br><span class="line">// 基准测试循环</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">Add(1, 2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BenchmarkAdd 是基准测试函数。基准测试函数必须以 Benchmark 开头，并接收一个 *testing.B 类型的参数。</li><li>b.N 是基准测试的循环次数。testing.B 会根据需要调整这个值，以确保测试的执行时间足够长，能准确地测量性能。</li><li>b.N 会自动增长，确保函数执行足够多次，以消除偶然的波动。</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\code2024\go<span class="literal">-practice</span>&gt; go test <span class="literal">-bench</span> .</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: go<span class="literal">-practice</span></span><br><span class="line">cpu: Intel(<span class="built_in">R</span>) Core(TM) i7<span class="literal">-1065G7</span> CPU <span class="selector-tag">@</span> <span class="number">1.30</span>GHz</span><br><span class="line">Benchmark<span class="built_in">Add-8</span>          <span class="number">1000000000</span>               <span class="number">0.3078</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      go<span class="literal">-practice</span>     <span class="number">0.829</span>s</span><br></pre></td></tr></table></figure><p>如果在运行前基准测试需要一些耗时的配置，则可以使用 b.ResetTimer() 先重置定时器，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkHello(b *testing.B) &#123;</span><br><span class="line">    ... // 耗时操作</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        fmt.Sprintf(&quot;hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;零基础小白可放心食用！有很多概念解释比如匹配or通配符等等，一起加油！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>go-并发编程</title>
    <link href="http://example.com/2024/11/25/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/11/25/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-11-25T21:22:15.000Z</published>
    <updated>2024-11-26T16:03:24.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前从未接触过并发编程的童鞋可放心食用！  </p><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><ul><li>并发 (Concurrency)：<br>并发是指同时处理多个任务的能力，但这些任务不一定是同时执行的。任务可能通过切换来共享时间片。  </li><li>并行 (Parallelism)：<br>并行是指多个任务同时执行，需要多个处理器核心支持。在 Go 中，Goroutine 是通过调度器来实现并发，最终通过 CPU 核心实现并行。</li></ul><p>并发和并行的关系：<br>并发是逻辑上的任务切换，而并行是物理上的任务同时运行。</p><h1 id="Go的并发核心：Goroutine"><a href="#Go的并发核心：Goroutine" class="headerlink" title="Go的并发核心：Goroutine"></a>Go的并发核心：Goroutine</h1><h2 id="Goroutine是什么"><a href="#Goroutine是什么" class="headerlink" title="Goroutine是什么"></a>Goroutine是什么</h2><p>Goroutine 是 Go 的协程实现，是一种比传统线程更轻量级的并发任务单元。</p><ul><li>轻量：一个 Goroutine 启动时仅占用大约 2 KB 的内存（相比线程，通常占用 1 MB 堆栈）。  </li><li>调度灵活：由 Go 的运行时（runtime）管理调度，而不是直接依赖操作系统内核线程。  </li><li>高效：Go 的运行时会动态调整 Goroutine 的栈大小（最小 2 KB，最大可达 1 GB），并通过用户态线程池实现调度。  </li></ul><p>协程 vs 线程：  </p><ul><li>线程：由操作系统调度，重量级，开销较大（如栈内存固定且较大、上下文切换代价高）。  </li><li>协程：由语言运行时调度，轻量级，开销小（动态栈、用户态上下文切换）。</li></ul><h2 id="创建和使用-Goroutine"><a href="#创建和使用-Goroutine" class="headerlink" title="创建和使用 Goroutine"></a>创建和使用 Goroutine</h2><p>创建一个 Goroutine 的方法非常简单，使用 go 关键字即可。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Task is running&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> task() <span class="comment">// 启动一个 Goroutine</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Main function&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 确保主 Goroutine 不退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>运行结果（顺序不可预测，Task is running可能都不会输出）：</em></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main function</span><br><span class="line">Task is running</span><br></pre></td></tr></table></figure><ul><li>go task()：启动一个新的 Goroutine，运行 task 函数。</li><li>主 Goroutine 继续执行 fmt.Println(“Main function”)。</li><li>如果没有 time.Sleep，主 Goroutine 会立即退出，程序结束，task 可能尚未完成。 </li></ul><h2 id="Goroutine的生命周期"><a href="#Goroutine的生命周期" class="headerlink" title="Goroutine的生命周期"></a>Goroutine的生命周期</h2><p>(1) 启动 Goroutine  </p><ul><li>Goroutine 是通过 go 关键字启动的。</li><li>每个 Goroutine 都会独立执行其任务，但与其他 Goroutine 和主 Goroutine 共享相同的地址空间。  </li></ul><p>(2) 运行中</p><ul><li>Goroutine 的调度由 Go 运行时管理，运行时会将多个 Goroutine 映射到少量的系统线程（M:N 模型）。</li><li>Goroutine 的执行顺序不确定，由运行时的调度算法决定。  </li></ul><p>(3) 结束</p><ul><li>Goroutine 执行完成或返回时会自动退出，无需显式销毁。</li></ul><h1 id="Goroutine-之间的同步与通信工具"><a href="#Goroutine-之间的同步与通信工具" class="headerlink" title="Goroutine 之间的同步与通信工具"></a>Goroutine 之间的同步与通信工具</h1><h2 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h2><p>sync 提供了一组基础的同步原语，用于解决 Goroutine 之间的同步问题，确保共享数据在多 Goroutine 环境下安全访问。</p><h3 id="常见的-sync-工具"><a href="#常见的-sync-工具" class="headerlink" title="常见的 sync 工具"></a>常见的 sync 工具</h3><p> <em>(1) sync.WaitGroup</em><br> 作用：等待一组 Goroutine 完成。<br> WaitGroup 提供了三个方法：</p><ul><li>Add(delta int)：设置需要等待的 Goroutine 数量（+delta）。</li><li>Done()：每当一个 Goroutine 完成任务，调用一次，表示减少一个需要等待的任务（-1）。</li><li>Wait()：阻塞主 Goroutine，直到所有计数归零。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// 减少计数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d is starting\n&quot;</span>, id)</span><br><span class="line"><span class="comment">// 模拟工作任务</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d is done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 增加计数</span></span><br><span class="line"><span class="keyword">go</span> worker(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">// 阻塞，直到所有任务完成</span></span><br><span class="line">fmt.Println(<span class="string">&quot;All workers are done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>注：Goroutines 是按照 for 循环的顺序启动的（1, 2, 3）。这意味着 Goroutines 被创建时的顺序是确定的。实际执行顺序取决于 Go 运行时调度器，调度器会决定哪个 Goroutine 先运行。</em></li></ul><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>Channel 是 Go 语言中用于 在 Goroutines 之间传递数据的核心机制之一。它是 Go 中并发编程的一个重要特性，可以让不同的 Goroutines 安全地通信和同步。Channel 是一种类型化的管道，可以用于在多个 Goroutines 之间传递消息，且无需使用锁（mutex）来保证同步。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><em>声明与初始化</em>：<br>使用 make 函数创建一个 channel，并可以指定容量（缓冲区大小）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> Type  <span class="comment">// 声明一个空的 channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> Type)  <span class="comment">// 创建一个 channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Type)  <span class="comment">// 声明并初始化一个 channel</span></span><br><span class="line"><span class="comment">//Type 是通过 channel 传递的数据类型，表示你希望在 channel 中传递的数据类型。</span></span><br></pre></td></tr></table></figure><br><em>发送数据&amp;接收数据</em><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- data  <span class="comment">// 将数据发送到 channel</span></span><br><span class="line">data := &lt;-ch  <span class="comment">// 从 channel 接收数据并赋值给变量</span></span><br></pre></td></tr></table></figure><br><em>关闭 Channel</em><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)  <span class="comment">// 关闭 channel</span></span><br><span class="line"><span class="comment">//使用 close(ch) 来关闭一个 channel，表示没有更多的数据会发送到该 channel。</span></span><br><span class="line"><span class="comment">//close 主要用于通知接收方，数据传输已经结束，接收方可以在接收数据时检查 channel 是否已关闭。</span></span><br></pre></td></tr></table></figure></p><h3 id="缓冲区与非缓冲区"><a href="#缓冲区与非缓冲区" class="headerlink" title="缓冲区与非缓冲区"></a>缓冲区与非缓冲区</h3><ul><li>非缓冲 channel：<br>发送方和接收方必须同时准备好，才能完成数据传递。发送方在发送数据时会阻塞，直到有接收方准备好接收数据。  </li><li>缓冲 channel：<br>可以预设一个缓冲区大小，在发送数据时，若缓冲区未满，发送方不会阻塞。只有当缓冲区满时，发送方才会被阻塞。接收方也不会立即阻塞，直到缓冲区为空时</li></ul><p><strong>非缓冲channel示例</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)  <span class="comment">// 创建一个非缓冲 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个 Goroutine 发送数据</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="string">&quot;Hello, Go!&quot;</span>  <span class="comment">// 发送数据到 channel</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据并输出</span></span><br><span class="line">    message := &lt;-ch  <span class="comment">// 从 channel 接收数据</span></span><br><span class="line">    fmt.Println(message)  <span class="comment">// 输出接收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>主 Goroutine 会阻塞在 message := &lt;-ch 直到接收到来自其他 Goroutine 的数据。</li><li>ch &lt;- “Hello, Go!” 会将数据发送到 channel，并且发送操作会阻塞，直到主 Goroutine 执行完 &lt;-ch 来接收数据。</li></ul><p><strong>缓冲channel示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan string, 2)  // 创建一个缓冲区大小为 2 的 channel</span><br><span class="line"></span><br><span class="line">    // 启动一个 Goroutine 发送数据</span><br><span class="line">    go func() &#123;</span><br><span class="line">        ch &lt;- &quot;Message 1&quot;</span><br><span class="line">        ch &lt;- &quot;Message 2&quot;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    // 接收并输出数据</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>创建了一个缓冲区大小为 2 的 channel，因此可以在没有阻塞的情况下向 channel 发送 2 条消息。</li><li>当我们从 channel 中接收数据时，如果缓冲区不为空，就能顺利获取到数据。</li><li>若发送3条消息，则会阻塞，直到缓冲区被释放</li></ul><h3 id="Channel-的同步与-Goroutines-协作"><a href="#Channel-的同步与-Goroutines-协作" class="headerlink" title="Channel 的同步与 Goroutines 协作"></a>Channel 的同步与 Goroutines 协作</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)  <span class="comment">// 模拟任务执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is done\n&quot;</span>, id)</span><br><span class="line">    ch &lt;- <span class="literal">true</span>  <span class="comment">// 通知任务完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">3</span>)  <span class="comment">// 创建一个缓冲区大小为 3 的 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(i, ch)  <span class="comment">// 启动多个 Goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有 Goroutine 完成</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        &lt;-ch  <span class="comment">// 从 channel 接收任务完成的信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;All workers are done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里使用了一个 缓冲 channel 来通知主 Goroutine 每个子 Goroutine 的任务完成。每个工作 Goroutine 在完成任务后通过 ch &lt;- true 向 channel 发送信号。</li><li>主 Goroutine 在 for 循环中通过 &lt;-ch 等待所有任务的完成，直到接收到所有的完成信号。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前从未接触过并发编程的童鞋可放心食用！  &lt;/p&gt;
&lt;h1 id=&quot;并发与并行&quot;&gt;&lt;a href=&quot;#并发与并行&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>go-语言</title>
    <link href="http://example.com/2024/11/25/go-%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2024/11/25/go-%E8%AF%AD%E8%A8%80/</id>
    <published>2024-11-25T16:09:19.000Z</published>
    <updated>2024-11-26T16:03:24.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>语言学习来源：</p><ul><li><a href="https://gobyexample-cn.github.io/">go-by-example</a></li><li><a href="https://geektutu.com/post/quick-golang.html">极客兔兔go简明教程</a>  </li></ul><p>原来过语言是看个输入输出直接去做题（但是后面看其实没怎么学跟项目有关的），而且这赶上期末&amp;手上有抓紧的项目，换一种方法。速通一下语言，之前学过一点点go语言皮毛，本文主要记录go在语言方面我觉得有趣不同的地方。ps：下一篇涉及并发编程&amp;单元测试</p><h1 id="string-amp-rune"><a href="#string-amp-rune" class="headerlink" title="string&amp;rune"></a>string&amp;rune</h1><p>字符串是以 byte 数组形式保存的，类型是 uint8，占1个 byte（中文一般占3byte），打印时需要用 string 进行类型转换&amp;用printf格式化，否则打印的是编码值。<br>为了更方便地处理字符（尤其是 Unicode 字符），Go 提供了 rune 类型作为字符的抽象，尤其是在处理多字节字符时，例如，字符 汉 是一个 Unicode 字符，在 UTF-8 编码下占用了 3 个字节，但作为 rune 类型，它是一个单独的值，可以直接进行操作。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, 世界!&quot;</span></span><br><span class="line">rs := []<span class="type">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> runes &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>, r) </span><br><span class="line">     <span class="comment">// 输出每个字符，分别是 H e l l o ,   世 界 !</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片实际上是一个描述符，包含以下三个部分：  </p><ul><li>指向底层数组的指针：切片的数据存储在底层数组中。  </li><li>长度（length）：切片当前的元素数。  </li><li>容量（capacity）：从切片起始位置到底层数组末尾的最大元素数。  </li></ul><p>多个切片可能共享同一个底层数组，如果需要独立操作，应使用 copy 创建新的切片。如果切片扩容导致底层数组更换，原切片和新切片将不再共享同一数组。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从数组创建</span></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  <span class="comment">// 数组</span></span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">4</span>]                 <span class="comment">// 从数组创建切片，包含索引 1 到 3 的元素</span></span><br><span class="line">fmt.Println(s)                <span class="comment">// [2 3 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)          <span class="comment">// 创建长度为 5 的切片，初始值为零值</span></span><br><span class="line">fmt.Println(s)               <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)      <span class="comment">// 创建长度为 3，容量为 5 的切片</span></span><br><span class="line">fmt.Println(s2)              <span class="comment">// [0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//make函数</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//type: 数据结构的类型，必须是 slice、map 或 channel。</span></span><br><span class="line"><span class="comment">//len: 数据结构的长度（对于切片和通道来说是可选参数）。</span></span><br><span class="line"><span class="comment">//cap: 数据结构的容量（仅对切片和带缓冲的通道有效，是可选参数）。</span></span><br><span class="line"><span class="comment">//如果没有显式指定容量，默认容量等于长度：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取长度，容量</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 长度: 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">// 容量: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片  </span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sub := s[<span class="number">1</span>:<span class="number">4</span>]         <span class="comment">// 从索引 1 到索引 3（不包含 4）</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [2 3 4]</span></span><br><span class="line"></span><br><span class="line">sub = s[:<span class="number">3</span>]           <span class="comment">// 从索引 0 到 2</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [1 2 3]</span></span><br><span class="line"></span><br><span class="line">sub = s[<span class="number">2</span>:]           <span class="comment">// 从索引 2 到末尾</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [3 4 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增长</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>)   <span class="comment">// 增加多个元素</span></span><br><span class="line">fmt.Println(s)        <span class="comment">// [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅声明</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 声明时初始化</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Sam&quot;</span>: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line"><span class="string">&quot;Alice&quot;</span>: <span class="string">&quot;Female&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="defer-amp-recover"><a href="#defer-amp-recover" class="headerlink" title="defer&amp;recover"></a>defer&amp;recover</h1><p>被 defer 的函数调用会在所在函数返回前（无论是正常返回还是因 panic 提前退出）被执行。<br>函数运行时，先跑别的，然后去找并运行defer函数（<em>被 defer 的函数调用会在所在函数返回前——无论是正常返回还是因 panic 提前退出——被执行。</em>）。在defer函数内部调用recover函数，捕获恢复程序<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(index <span class="type">int</span>)</span></span> (ret <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Some error happened!&quot;</span>, r)</span><br><span class="line">ret = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">return</span> arr[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(get(<span class="number">5</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">getName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stu.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p Person = &amp;Student&#123;</span><br><span class="line">name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(p.getName()) <span class="comment">// Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：  </p><ul><li>定义接口 Person 和两个结构体 Student 和 Worker。  </li><li>实现 getName 方法，使得 <em>Student 和 </em>Worker 都满足 Person 接口。  </li><li>在 main 函数中：<ul><li>创建一个 *Student 的实例。</li><li>将其赋值给 Person 类型变量 p。</li><li>调用 p.getName() 方法，实际执行的是 *Student.getName，返回 Tom。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;语言学习来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gobyexample-cn.github.io/&quot;&gt;go-by</summary>
      
    
    
    
    
  </entry>
  
</feed>
