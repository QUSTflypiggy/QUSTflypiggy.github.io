<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flypiggy&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-25T15:50:19.695Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>qustfp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go-并发编程</title>
    <link href="http://example.com/2024/11/25/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/11/25/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-11-25T21:22:15.000Z</published>
    <updated>2024-11-25T15:50:19.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前从未接触过并发编程的童鞋可放心食用！  </p><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><ul><li>并发 (Concurrency)：<br>并发是指同时处理多个任务的能力，但这些任务不一定是同时执行的。任务可能通过切换来共享时间片。  </li><li>并行 (Parallelism)：<br>并行是指多个任务同时执行，需要多个处理器核心支持。在 Go 中，Goroutine 是通过调度器来实现并发，最终通过 CPU 核心实现并行。</li></ul><p>并发和并行的关系：<br>并发是逻辑上的任务切换，而并行是物理上的任务同时运行。</p><h1 id="Go的并发核心：Goroutine"><a href="#Go的并发核心：Goroutine" class="headerlink" title="Go的并发核心：Goroutine"></a>Go的并发核心：Goroutine</h1><h2 id="Goroutine是什么"><a href="#Goroutine是什么" class="headerlink" title="Goroutine是什么"></a>Goroutine是什么</h2><p>Goroutine 是 Go 的协程实现，是一种比传统线程更轻量级的并发任务单元。</p><ul><li>轻量：一个 Goroutine 启动时仅占用大约 2 KB 的内存（相比线程，通常占用 1 MB 堆栈）。  </li><li>调度灵活：由 Go 的运行时（runtime）管理调度，而不是直接依赖操作系统内核线程。  </li><li>高效：Go 的运行时会动态调整 Goroutine 的栈大小（最小 2 KB，最大可达 1 GB），并通过用户态线程池实现调度。  </li></ul><p>协程 vs 线程：  </p><ul><li>线程：由操作系统调度，重量级，开销较大（如栈内存固定且较大、上下文切换代价高）。  </li><li>协程：由语言运行时调度，轻量级，开销小（动态栈、用户态上下文切换）。</li></ul><h2 id="创建和使用-Goroutine"><a href="#创建和使用-Goroutine" class="headerlink" title="创建和使用 Goroutine"></a>创建和使用 Goroutine</h2><p>创建一个 Goroutine 的方法非常简单，使用 go 关键字即可。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Task is running&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> task() <span class="comment">// 启动一个 Goroutine</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Main function&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 确保主 Goroutine 不退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>运行结果（顺序不可预测，Task is running可能都不会输出）：</em></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main function</span><br><span class="line">Task is running</span><br></pre></td></tr></table></figure><ul><li>go task()：启动一个新的 Goroutine，运行 task 函数。</li><li>主 Goroutine 继续执行 fmt.Println(“Main function”)。</li><li>如果没有 time.Sleep，主 Goroutine 会立即退出，程序结束，task 可能尚未完成。 </li></ul><h2 id="Goroutine的生命周期"><a href="#Goroutine的生命周期" class="headerlink" title="Goroutine的生命周期"></a>Goroutine的生命周期</h2><p>(1) 启动 Goroutine  </p><ul><li>Goroutine 是通过 go 关键字启动的。</li><li>每个 Goroutine 都会独立执行其任务，但与其他 Goroutine 和主 Goroutine 共享相同的地址空间。  </li></ul><p>(2) 运行中</p><ul><li>Goroutine 的调度由 Go 运行时管理，运行时会将多个 Goroutine 映射到少量的系统线程（M:N 模型）。</li><li>Goroutine 的执行顺序不确定，由运行时的调度算法决定。  </li></ul><p>(3) 结束</p><ul><li>Goroutine 执行完成或返回时会自动退出，无需显式销毁。</li></ul><h1 id="Goroutine-之间的同步与通信工具"><a href="#Goroutine-之间的同步与通信工具" class="headerlink" title="Goroutine 之间的同步与通信工具"></a>Goroutine 之间的同步与通信工具</h1><h2 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h2><p>sync 提供了一组基础的同步原语，用于解决 Goroutine 之间的同步问题，确保共享数据在多 Goroutine 环境下安全访问。</p><h3 id="常见的-sync-工具"><a href="#常见的-sync-工具" class="headerlink" title="常见的 sync 工具"></a>常见的 sync 工具</h3><p> <em>(1) sync.WaitGroup</em><br> 作用：等待一组 Goroutine 完成。<br> WaitGroup 提供了三个方法：</p><ul><li>Add(delta int)：设置需要等待的 Goroutine 数量（+delta）。</li><li>Done()：每当一个 Goroutine 完成任务，调用一次，表示减少一个需要等待的任务（-1）。</li><li>Wait()：阻塞主 Goroutine，直到所有计数归零。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// 减少计数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d is starting\n&quot;</span>, id)</span><br><span class="line"><span class="comment">// 模拟工作任务</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d is done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 增加计数</span></span><br><span class="line"><span class="keyword">go</span> worker(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">// 阻塞，直到所有任务完成</span></span><br><span class="line">fmt.Println(<span class="string">&quot;All workers are done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>注：Goroutines 是按照 for 循环的顺序启动的（1, 2, 3）。这意味着 Goroutines 被创建时的顺序是确定的。实际执行顺序取决于 Go 运行时调度器，调度器会决定哪个 Goroutine 先运行。</em></li></ul><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>Channel 是 Go 语言中用于 在 Goroutines 之间传递数据的核心机制之一。它是 Go 中并发编程的一个重要特性，可以让不同的 Goroutines 安全地通信和同步。Channel 是一种类型化的管道，可以用于在多个 Goroutines 之间传递消息，且无需使用锁（mutex）来保证同步。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><em>声明与初始化</em>：<br>使用 make 函数创建一个 channel，并可以指定容量（缓冲区大小）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> Type  <span class="comment">// 声明一个空的 channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> Type)  <span class="comment">// 创建一个 channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Type)  <span class="comment">// 声明并初始化一个 channel</span></span><br><span class="line"><span class="comment">//Type 是通过 channel 传递的数据类型，表示你希望在 channel 中传递的数据类型。</span></span><br></pre></td></tr></table></figure><br><em>发送数据&amp;接收数据</em><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- data  <span class="comment">// 将数据发送到 channel</span></span><br><span class="line">data := &lt;-ch  <span class="comment">// 从 channel 接收数据并赋值给变量</span></span><br></pre></td></tr></table></figure><br><em>关闭 Channel</em><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)  <span class="comment">// 关闭 channel</span></span><br><span class="line"><span class="comment">//使用 close(ch) 来关闭一个 channel，表示没有更多的数据会发送到该 channel。</span></span><br><span class="line"><span class="comment">//close 主要用于通知接收方，数据传输已经结束，接收方可以在接收数据时检查 channel 是否已关闭。</span></span><br></pre></td></tr></table></figure></p><h3 id="缓冲区与非缓冲区"><a href="#缓冲区与非缓冲区" class="headerlink" title="缓冲区与非缓冲区"></a>缓冲区与非缓冲区</h3><ul><li>非缓冲 channel：<br>发送方和接收方必须同时准备好，才能完成数据传递。发送方在发送数据时会阻塞，直到有接收方准备好接收数据。  </li><li>缓冲 channel：<br>可以预设一个缓冲区大小，在发送数据时，若缓冲区未满，发送方不会阻塞。只有当缓冲区满时，发送方才会被阻塞。接收方也不会立即阻塞，直到缓冲区为空时</li></ul><p><strong>非缓冲channel示例</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)  <span class="comment">// 创建一个非缓冲 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个 Goroutine 发送数据</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="string">&quot;Hello, Go!&quot;</span>  <span class="comment">// 发送数据到 channel</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据并输出</span></span><br><span class="line">    message := &lt;-ch  <span class="comment">// 从 channel 接收数据</span></span><br><span class="line">    fmt.Println(message)  <span class="comment">// 输出接收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>主 Goroutine 会阻塞在 message := &lt;-ch 直到接收到来自其他 Goroutine 的数据。</li><li>ch &lt;- “Hello, Go!” 会将数据发送到 channel，并且发送操作会阻塞，直到主 Goroutine 执行完 &lt;-ch 来接收数据。</li></ul><p><strong>缓冲channel示例</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan string, 2)  // 创建一个缓冲区大小为 2 的 channel</span><br><span class="line"></span><br><span class="line">    // 启动一个 Goroutine 发送数据</span><br><span class="line">    go func() &#123;</span><br><span class="line">        ch &lt;- &quot;Message 1&quot;</span><br><span class="line">        ch &lt;- &quot;Message 2&quot;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    // 接收并输出数据</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>创建了一个缓冲区大小为 2 的 channel，因此可以在没有阻塞的情况下向 channel 发送 2 条消息。</li><li>当我们从 channel 中接收数据时，如果缓冲区不为空，就能顺利获取到数据。</li><li>若发送3条消息，则会阻塞，直到缓冲区被释放</li></ul><h3 id="Channel-的同步与-Goroutines-协作"><a href="#Channel-的同步与-Goroutines-协作" class="headerlink" title="Channel 的同步与 Goroutines 协作"></a>Channel 的同步与 Goroutines 协作</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)  <span class="comment">// 模拟任务执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is done\n&quot;</span>, id)</span><br><span class="line">    ch &lt;- <span class="literal">true</span>  <span class="comment">// 通知任务完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">3</span>)  <span class="comment">// 创建一个缓冲区大小为 3 的 channel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(i, ch)  <span class="comment">// 启动多个 Goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有 Goroutine 完成</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        &lt;-ch  <span class="comment">// 从 channel 接收任务完成的信号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;All workers are done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里使用了一个 缓冲 channel 来通知主 Goroutine 每个子 Goroutine 的任务完成。每个工作 Goroutine 在完成任务后通过 ch &lt;- true 向 channel 发送信号。</li><li>主 Goroutine 在 for 循环中通过 &lt;-ch 等待所有任务的完成，直到接收到所有的完成信号。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前从未接触过并发编程的童鞋可放心食用！  &lt;/p&gt;
&lt;h1 id=&quot;并发与并行&quot;&gt;&lt;a href=&quot;#并发与并行&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>go-语言</title>
    <link href="http://example.com/2024/11/25/go-%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2024/11/25/go-%E8%AF%AD%E8%A8%80/</id>
    <published>2024-11-25T16:09:19.000Z</published>
    <updated>2024-11-25T15:50:19.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>语言学习来源：</p><ul><li><a href="https://gobyexample-cn.github.io/">go-by-example</a></li><li><a href="https://geektutu.com/post/quick-golang.html">极客兔兔go简明教程</a>  </li></ul><p>原来过语言是看个输入输出直接去做题（但是后面看其实没怎么学跟项目有关的），而且这赶上期末&amp;手上有抓紧的项目，换一种方法。速通一下语言，之前学过一点点go语言皮毛，本文主要记录go在语言方面我觉得有趣不同的地方。ps：下一篇涉及并发编程&amp;单元测试</p><h1 id="string-amp-rune"><a href="#string-amp-rune" class="headerlink" title="string&amp;rune"></a>string&amp;rune</h1><p>字符串是以 byte 数组形式保存的，类型是 uint8，占1个 byte（中文一般占3byte），打印时需要用 string 进行类型转换&amp;用printf格式化，否则打印的是编码值。<br>为了更方便地处理字符（尤其是 Unicode 字符），Go 提供了 rune 类型作为字符的抽象，尤其是在处理多字节字符时，例如，字符 汉 是一个 Unicode 字符，在 UTF-8 编码下占用了 3 个字节，但作为 rune 类型，它是一个单独的值，可以直接进行操作。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, 世界!&quot;</span></span><br><span class="line">rs := []<span class="type">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> runes &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>, r) </span><br><span class="line">     <span class="comment">// 输出每个字符，分别是 H e l l o ,   世 界 !</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片实际上是一个描述符，包含以下三个部分：  </p><ul><li>指向底层数组的指针：切片的数据存储在底层数组中。  </li><li>长度（length）：切片当前的元素数。  </li><li>容量（capacity）：从切片起始位置到底层数组末尾的最大元素数。  </li></ul><p>多个切片可能共享同一个底层数组，如果需要独立操作，应使用 copy 创建新的切片。如果切片扩容导致底层数组更换，原切片和新切片将不再共享同一数组。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从数组创建</span></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  <span class="comment">// 数组</span></span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">4</span>]                 <span class="comment">// 从数组创建切片，包含索引 1 到 3 的元素</span></span><br><span class="line">fmt.Println(s)                <span class="comment">// [2 3 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用make</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)          <span class="comment">// 创建长度为 5 的切片，初始值为零值</span></span><br><span class="line">fmt.Println(s)               <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)      <span class="comment">// 创建长度为 3，容量为 5 的切片</span></span><br><span class="line">fmt.Println(s2)              <span class="comment">// [0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//make函数</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">//type: 数据结构的类型，必须是 slice、map 或 channel。</span></span><br><span class="line"><span class="comment">//len: 数据结构的长度（对于切片和通道来说是可选参数）。</span></span><br><span class="line"><span class="comment">//cap: 数据结构的容量（仅对切片和带缓冲的通道有效，是可选参数）。</span></span><br><span class="line"><span class="comment">//如果没有显式指定容量，默认容量等于长度：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取长度，容量</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 长度: 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">// 容量: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片  </span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">sub := s[<span class="number">1</span>:<span class="number">4</span>]         <span class="comment">// 从索引 1 到索引 3（不包含 4）</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [2 3 4]</span></span><br><span class="line"></span><br><span class="line">sub = s[:<span class="number">3</span>]           <span class="comment">// 从索引 0 到 2</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [1 2 3]</span></span><br><span class="line"></span><br><span class="line">sub = s[<span class="number">2</span>:]           <span class="comment">// 从索引 2 到末尾</span></span><br><span class="line">fmt.Println(sub)      <span class="comment">// [3 4 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增长</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>)   <span class="comment">// 增加多个元素</span></span><br><span class="line">fmt.Println(s)        <span class="comment">// [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅声明</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 声明时初始化</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Sam&quot;</span>: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line"><span class="string">&quot;Alice&quot;</span>: <span class="string">&quot;Female&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="defer-amp-recover"><a href="#defer-amp-recover" class="headerlink" title="defer&amp;recover"></a>defer&amp;recover</h1><p>被 defer 的函数调用会在所在函数返回前（无论是正常返回还是因 panic 提前退出）被执行。<br>函数运行时，先跑别的，然后去找并运行defer函数（<em>被 defer 的函数调用会在所在函数返回前——无论是正常返回还是因 panic 提前退出——被执行。</em>）。在defer函数内部调用recover函数，捕获恢复程序<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(index <span class="type">int</span>)</span></span> (ret <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Some error happened!&quot;</span>, r)</span><br><span class="line">ret = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">return</span> arr[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(get(<span class="number">5</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">getName() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> stu.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">gender <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p Person = &amp;Student&#123;</span><br><span class="line">name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(p.getName()) <span class="comment">// Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：  </p><ul><li>定义接口 Person 和两个结构体 Student 和 Worker。  </li><li>实现 getName 方法，使得 <em>Student 和 </em>Worker 都满足 Person 接口。  </li><li>在 main 函数中：<ul><li>创建一个 *Student 的实例。</li><li>将其赋值给 Person 类型变量 p。</li><li>调用 p.getName() 方法，实际执行的是 *Student.getName，返回 Tom。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;语言学习来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gobyexample-cn.github.io/&quot;&gt;go-by</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/11/25/hello-world/"/>
    <id>http://example.com/2024/11/25/hello-world/</id>
    <published>2024-11-25T15:50:19.695Z</published>
    <updated>2024-11-25T15:50:19.695Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog!<br>好运气好心情!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to my blog!&lt;br&gt;好运气好心情!&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
